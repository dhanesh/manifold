#!/usr/bin/env bun
/**
 * Build-time Command Translator
 * Satisfies: RT-1 (build-time translator), T1 (command format translation), B3 (single canonical source)
 *
 * Translates canonical .md commands (with YAML frontmatter) into:
 * - Gemini CLI: .toml files in install/agents/gemini/commands/
 * - Codex CLI: SKILL.md files in install/agents/codex/skills/manifold-<cmd>/
 *
 * Claude Code and AMP receive the canonical .md files directly (no translation).
 *
 * Usage: bun run install/lib/build-commands.ts [--verify]
 */

import { readdirSync, readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, basename, parse as parsePath } from 'path';

// ============================================================
// Types
// ============================================================

interface CommandMeta {
  description: string;
  'argument-hint'?: string;
}

interface ParsedCommand {
  meta: CommandMeta;
  body: string;
  filename: string;
  commandName: string;
}

// ============================================================
// Parser: Extract YAML frontmatter from canonical .md
// ============================================================

function parseFrontmatter(content: string): { meta: Record<string, string>; body: string } {
  const fmMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  if (!fmMatch) {
    return { meta: {}, body: content };
  }

  const meta: Record<string, string> = {};
  for (const line of fmMatch[1].split('\n')) {
    const colonIdx = line.indexOf(':');
    if (colonIdx > 0) {
      const key = line.slice(0, colonIdx).trim();
      let value = line.slice(colonIdx + 1).trim();
      // Strip surrounding quotes
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
        // Unescape YAML double-quoted string escapes
        value = value.replace(/\\"/g, '"').replace(/\\\\/g, '\\');
      }
      meta[key] = value;
    }
  }

  return { meta, body: fmMatch[2] };
}

function parseCanonicalCommand(filepath: string): ParsedCommand {
  const content = readFileSync(filepath, 'utf-8');
  const { meta, body } = parseFrontmatter(content);
  const filename = basename(filepath);
  const commandName = parsePath(filepath).name; // e.g., "m0-init"

  return {
    meta: {
      description: meta.description || `Manifold ${commandName} command`,
      'argument-hint': meta['argument-hint'],
    },
    body,
    filename,
    commandName,
  };
}

// ============================================================
// Gemini: Emit .toml command files
// ============================================================

function escapeTomlString(s: string): string {
  // For multi-line strings, use triple-quoted TOML literals
  return s.replace(/\\/g, '\\\\').replace(/"""/g, '\\"\\"\\"');
}

function toGeminiToml(cmd: ParsedCommand): string {
  const desc = cmd.meta.description.replace(/"/g, '\\"');
  const argHint = cmd.meta['argument-hint']
    ? `\nargument_hint = "${cmd.meta['argument-hint'].replace(/"/g, '\\"')}"`
    : '';

  // Gemini custom commands use prompt (required) and description (optional)
  const prompt = cmd.body.trim();

  return `# Manifold command: /${cmd.commandName}
# Auto-generated by build-commands.ts — do not edit manually
# Satisfies: T1 (command format translation), B3 (single canonical source)

description = "${desc}"${argHint}
prompt = """
${escapeTomlString(prompt)}
"""
`;
}

function writeGeminiCommands(commands: ParsedCommand[], outDir: string): number {
  mkdirSync(outDir, { recursive: true });
  let count = 0;
  for (const cmd of commands) {
    // Skip non-command files like SCHEMA_REFERENCE.md
    if (!cmd.commandName.startsWith('m') && cmd.commandName !== 'parallel') continue;

    const toml = toGeminiToml(cmd);
    const outPath = join(outDir, `${cmd.commandName}.toml`);
    writeFileSync(outPath, toml, 'utf-8');
    count++;
  }
  return count;
}

// ============================================================
// Codex: Emit SKILL.md skill directories
// ============================================================

function toCodexSkillMd(cmd: ParsedCommand): string {
  // Codex SKILL.md uses name + description metadata at the top,
  // followed by the skill content as markdown instructions
  const name = `manifold-${cmd.commandName}`;
  // Quote description to avoid YAML parsing issues with colons
  const desc = cmd.meta.description.replace(/"/g, '\\"');

  return `---
name: ${name}
description: "${desc}"
---

# /${cmd.commandName}

${cmd.body.trim()}
`;
}

function writeCodexSkills(commands: ParsedCommand[], outDir: string): number {
  mkdirSync(outDir, { recursive: true });
  let count = 0;
  for (const cmd of commands) {
    if (!cmd.commandName.startsWith('m') && cmd.commandName !== 'parallel') continue;

    const skillDir = join(outDir, `manifold-${cmd.commandName}`);
    mkdirSync(skillDir, { recursive: true });

    const skillMd = toCodexSkillMd(cmd);
    writeFileSync(join(skillDir, 'SKILL.md'), skillMd, 'utf-8');
    count++;
  }
  return count;
}

// ============================================================
// Verification mode
// ============================================================

function verifyOutputs(geminiDir: string, codexDir: string, expectedCount: number): boolean {
  let ok = true;

  // Check Gemini .toml files
  if (!existsSync(geminiDir)) {
    console.error(`✗ Gemini output directory missing: ${geminiDir}`);
    ok = false;
  } else {
    const tomlFiles = readdirSync(geminiDir).filter(f => f.endsWith('.toml'));
    if (tomlFiles.length !== expectedCount) {
      console.error(`✗ Expected ${expectedCount} Gemini .toml files, found ${tomlFiles.length}`);
      ok = false;
    } else {
      console.log(`✓ ${tomlFiles.length} Gemini .toml files`);
    }
  }

  // Check Codex SKILL.md directories
  if (!existsSync(codexDir)) {
    console.error(`✗ Codex output directory missing: ${codexDir}`);
    ok = false;
  } else {
    // Count only command-derived skills (exclude manually-created manifold-context, manifold-suggest)
    const skillDirs = readdirSync(codexDir).filter(d =>
      existsSync(join(codexDir, d, 'SKILL.md'))
    );
    const commandSkillDirs = skillDirs.filter(d =>
      d.startsWith('manifold-m') || d === 'manifold-parallel'
    );
    if (commandSkillDirs.length !== expectedCount) {
      console.error(`✗ Expected ${expectedCount} Codex command skill dirs, found ${commandSkillDirs.length}`);
      ok = false;
    } else {
      console.log(`✓ ${commandSkillDirs.length} Codex command skill directories (${skillDirs.length} total with hook skills)`);
    }
  }

  return ok;
}

// ============================================================
// Main
// ============================================================

export function buildCommands(
  sourceDir: string,
  geminiOutDir: string,
  codexOutDir: string,
): { geminiCount: number; codexCount: number } {
  // Read all canonical .md commands
  const mdFiles = readdirSync(sourceDir)
    .filter(f => f.endsWith('.md'))
    .map(f => join(sourceDir, f));

  const commands = mdFiles.map(parseCanonicalCommand);

  // Generate Gemini .toml files
  const geminiCount = writeGeminiCommands(commands, geminiOutDir);

  // Generate Codex SKILL.md directories
  const codexCount = writeCodexSkills(commands, codexOutDir);

  return { geminiCount, codexCount };
}

// CLI entry point
if (import.meta.main) {
  const projectRoot = join(import.meta.dir, '..', '..');
  const sourceDir = join(projectRoot, 'install', 'commands');
  const geminiOutDir = join(projectRoot, 'install', 'agents', 'gemini', 'commands');
  const codexOutDir = join(projectRoot, 'install', 'agents', 'codex', 'skills');

  const isVerify = process.argv.includes('--verify');

  if (isVerify) {
    // Count expected command files (m* + parallel, excluding SCHEMA_*)
    const expectedCount = readdirSync(sourceDir)
      .filter(f => f.endsWith('.md'))
      .filter(f => {
        const name = parsePath(f).name;
        return name.startsWith('m') || name === 'parallel';
      })
      .length;

    const ok = verifyOutputs(geminiOutDir, codexOutDir, expectedCount);
    process.exit(ok ? 0 : 1);
  }

  console.log('Building agent-specific command files...');
  console.log(`  Source: ${sourceDir}`);

  const { geminiCount, codexCount } = buildCommands(sourceDir, geminiOutDir, codexOutDir);

  console.log(`  ✓ Gemini CLI: ${geminiCount} .toml files → ${geminiOutDir}`);
  console.log(`  ✓ Codex CLI:  ${codexCount} SKILL.md dirs → ${codexOutDir}`);
  console.log('Done.');
}
